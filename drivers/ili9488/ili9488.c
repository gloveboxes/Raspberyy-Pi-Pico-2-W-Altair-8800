/*****************************************************************************
 * ILI9488 LCD Driver for Waveshare 3.5" Pico Display
 * Based on Waveshare reference implementation
 *****************************************************************************/

#include "ili9488.h"
#include "hardware/gpio.h"
#include "hardware/spi.h"
#include "pico/mutex.h"
#include "pico/stdlib.h"
#include <stdio.h>
#include <string.h>

#define SPI_PORT spi1

// SPI bus mutex (shared with SD card on SPI1)
static mutex_t spi1_mutex;

// Forward declarations
static void lcd_write_reg(uint8_t reg);
static void lcd_write_data_byte(uint8_t data);
static void lcd_write_data_word(uint16_t data);
static void lcd_set_window(uint16_t x_start, uint16_t y_start, uint16_t x_end, uint16_t y_end);

/*******************************************************************************
 * GPIO and SPI helpers with mutex protection
 ******************************************************************************/
static inline void spi1_lock(void)
{
    mutex_enter_blocking(&spi1_mutex);
}

static inline void spi1_unlock(void)
{
    mutex_exit(&spi1_mutex);
}

static inline void cs_select(void)
{
    gpio_put(ILI9488_CS_PIN, 0);
}

static inline void cs_deselect(void)
{
    gpio_put(ILI9488_CS_PIN, 1);
}

static inline void dc_command(void)
{
    gpio_put(ILI9488_DC_PIN, 0);
}

static inline void dc_data(void)
{
    gpio_put(ILI9488_DC_PIN, 1);
}

static void spi_write_byte(uint8_t value)
{
    spi_write_blocking(SPI_PORT, &value, 1);
}

/*******************************************************************************
 * LCD low-level functions
 ******************************************************************************/
static void lcd_write_reg(uint8_t reg)
{
    dc_command();
    cs_select();
    spi_write_byte(reg);
    cs_deselect();
}

// Write single byte of data (for register configuration)
static void lcd_write_data_byte(uint8_t data)
{
    dc_data();
    cs_select();
    spi_write_byte(data);
    cs_deselect();
}

// Write 16-bit word as 2 bytes (for pixel data)
static void lcd_write_data_word(uint16_t data)
{
    dc_data();
    cs_select();
    spi_write_byte(data >> 8);
    spi_write_byte(data & 0xFF);
    cs_deselect();
}

static void lcd_reset(void)
{
    // Waveshare reference uses 500ms delays for reliable reset
    gpio_put(ILI9488_RST_PIN, 1);
    sleep_ms(500);
    gpio_put(ILI9488_RST_PIN, 0);
    sleep_ms(500);
    gpio_put(ILI9488_RST_PIN, 1);
    sleep_ms(500);
}

static void lcd_init_reg(void)
{
    // ILI9488 initialization sequence for 3.5" display
    // CRITICAL: Use lcd_write_data_byte() for single-byte register values
    // Use lcd_write_data_word() only for 16-bit pixel data

    lcd_write_reg(0x21); // Display Inversion ON

    lcd_write_reg(0xC2); // Power Control 3
    lcd_write_data_byte(0x33);

    lcd_write_reg(0xC5); // VCOM Control
    lcd_write_data_byte(0x00);
    lcd_write_data_byte(0x1E);
    lcd_write_data_byte(0x80);

    lcd_write_reg(0xB1); // Frame Rate Control
    lcd_write_data_byte(0xB0);

    // NOTE: Memory Access Control (0x36) is set in lcd_set_scan_direction()
    // Do NOT set it here - scan direction must be configured separately

    lcd_write_reg(0xE0); // Positive Gamma Control
    lcd_write_data_byte(0x00);
    lcd_write_data_byte(0x13);
    lcd_write_data_byte(0x18);
    lcd_write_data_byte(0x04);
    lcd_write_data_byte(0x0F);
    lcd_write_data_byte(0x06);
    lcd_write_data_byte(0x3A);
    lcd_write_data_byte(0x56);
    lcd_write_data_byte(0x4D);
    lcd_write_data_byte(0x03);
    lcd_write_data_byte(0x0A);
    lcd_write_data_byte(0x06);
    lcd_write_data_byte(0x30);
    lcd_write_data_byte(0x3E);
    lcd_write_data_byte(0x0F);

    lcd_write_reg(0xE1); // Negative Gamma Control
    lcd_write_data_byte(0x00);
    lcd_write_data_byte(0x13);
    lcd_write_data_byte(0x18);
    lcd_write_data_byte(0x01);
    lcd_write_data_byte(0x11);
    lcd_write_data_byte(0x06);
    lcd_write_data_byte(0x38);
    lcd_write_data_byte(0x34);
    lcd_write_data_byte(0x4D);
    lcd_write_data_byte(0x06);
    lcd_write_data_byte(0x0D);
    lcd_write_data_byte(0x0B);
    lcd_write_data_byte(0x31);
    lcd_write_data_byte(0x37);
    lcd_write_data_byte(0x0F);

    lcd_write_reg(0x3A); // Pixel Format: 16-bit RGB565
    lcd_write_data_byte(0x55);

    lcd_write_reg(0x11); // Sleep Out
    sleep_ms(120);

    lcd_write_reg(0x29); // Display On
}

static void lcd_set_scan_direction(void)
{
    // Set scan direction matching reference LCD_SetGramScanWay() for L2R_U2D mode
    // Reference values for 3.5" in L2R_U2D mode:
    // MemoryAccessReg_Data = 0x08
    // DisFunReg_Data = 0x22

    // Display Function Control (0xB6)
    lcd_write_reg(0xB6);
    lcd_write_data_byte(0x00);
    lcd_write_data_byte(0x22); // GS=0, SS=1 for L2R_U2D

    // Memory Access Control (0x36)
    lcd_write_reg(0x36);
    lcd_write_data_byte(0x08); // L2R_U2D mode - matches reference exactly
}

static void lcd_set_window(uint16_t x_start, uint16_t y_start, uint16_t x_end, uint16_t y_end)
{
    uint16_t x_end_addr = x_end - 1;
    uint16_t y_end_addr = y_end - 1;

    // Set Column Address (0x2A)
    // Waveshare sends each coordinate as 2 bytes (high, low) using LCD_WriteData which sends 2 bytes
    // For the 3.5" display, LCD_WriteData(value) sends: (value >> 8), (value & 0xFF)
    // So LCD_WriteData(x_start) sends the coordinate as high byte, low byte - 2 bytes total
    lcd_write_reg(0x2A);
    lcd_write_data_word(x_start);    // Sends x_start as (x_start >> 8), (x_start & 0xFF)
    lcd_write_data_word(x_end_addr); // Sends x_end as (x_end >> 8), (x_end & 0xFF)

    // Set Page Address (0x2B)
    lcd_write_reg(0x2B);
    lcd_write_data_word(y_start);
    lcd_write_data_word(y_end_addr);

    // Memory Write command (0x2C)
    lcd_write_reg(0x2C);
}

/*******************************************************************************
 * Public API
 ******************************************************************************/
void ili9488_init(void)
{
    // Initialize SPI1 mutex for shared bus protection
    mutex_init(&spi1_mutex);
    printf("[ILI9488] Mutex initialized for SPI1 bus protection\n");

    // Initialize LCD-specific GPIO pins ONLY
    // Do NOT touch SD card pins (GPIO 22) - they are managed by SD card driver

    gpio_init(ILI9488_RST_PIN);
    gpio_set_dir(ILI9488_RST_PIN, GPIO_OUT);

    gpio_init(ILI9488_DC_PIN);
    gpio_set_dir(ILI9488_DC_PIN, GPIO_OUT);

    gpio_init(ILI9488_CS_PIN);
    gpio_set_dir(ILI9488_CS_PIN, GPIO_OUT);
    gpio_put(ILI9488_CS_PIN, 1); // Deselect LCD

    gpio_init(ILI9488_BKL_PIN);
    gpio_set_dir(ILI9488_BKL_PIN, GPIO_OUT);
    gpio_put(ILI9488_BKL_PIN, 1); // Backlight ON

    gpio_init(ILI9488_TP_CS_PIN);
    gpio_set_dir(ILI9488_TP_CS_PIN, GPIO_OUT);
    gpio_put(ILI9488_TP_CS_PIN, 1); // Deselect Touch

    // Configure TP_IRQ (GPIO 17) with pull-up like Waveshare reference
    gpio_init(17);
    gpio_set_dir(17, GPIO_IN);
    gpio_set_pulls(17, true, false); // Pull-up enabled

    // Configure SPI pins for SPI function
    // This is needed because the pins might be in a different mode after SD card operations
    gpio_set_function(ILI9488_CLK_PIN, GPIO_FUNC_SPI);
    gpio_set_function(ILI9488_MOSI_PIN, GPIO_FUNC_SPI);
    gpio_set_function(ILI9488_MISO_PIN, GPIO_FUNC_SPI);

    // Initialize SPI at a slower speed for reliability (10 MHz)
    // The Waveshare docs say max write speed is 60 MHz but lower is safer
    spi_init(SPI_PORT, 4 * 1000 * 1000); // 4 MHz like Waveshare reference
    spi_set_format(SPI_PORT, 8, SPI_CPOL_0, SPI_CPHA_0, SPI_MSB_FIRST);

    printf("[ILI9488] Initializing display (SPI at 4 MHz)...\n");

    // Acquire SPI bus for initialization sequence
    spi1_lock();
    lcd_reset();
    lcd_init_reg();
    lcd_set_scan_direction();
    spi1_unlock();

    sleep_ms(100);
    printf("[ILI9488] Display initialized successfully\n");
}

void ili9488_deselect(void)
{
    cs_deselect();
}

// Convert RGB565 to RGB666 (3 bytes) for ILI9488 SPI interface
static inline void rgb565_to_rgb666(uint16_t color, uint8_t* r, uint8_t* g, uint8_t* b)
{
    // Extract RGB565 components: RRRRRGGGGGGBBBBB
    uint8_t r5 = (color >> 11) & 0x1F; // 5 bits
    uint8_t g6 = (color >> 5) & 0x3F;  // 6 bits
    uint8_t b5 = color & 0x1F;         // 5 bits

    // Convert to 8-bit and left-shift for RGB666 format (top 6 bits used)
    *r = (r5 << 3) | (r5 >> 2); // 5 bits -> 8 bits
    *g = (g6 << 2) | (g6 >> 4); // 6 bits -> 8 bits
    *b = (b5 << 3) | (b5 >> 2); // 5 bits -> 8 bits
}

void ili9488_clear(uint16_t color)
{
    spi1_lock();

    lcd_set_window(0, 0, ILI9488_WIDTH, ILI9488_HEIGHT);

    dc_data();
    cs_select();

    // RGB565: 2 bytes per pixel
    uint8_t high = color >> 8;
    uint8_t low = color & 0xFF;
    uint8_t buffer[512];

    for (int i = 0; i < 256; i++)
    {
        buffer[i * 2] = high;
        buffer[i * 2 + 1] = low;
    }

    // Write buffer repeatedly to fill display (480 * 320 = 153600 pixels)
    uint32_t total_pixels = ILI9488_WIDTH * ILI9488_HEIGHT;
    uint32_t pixels_per_chunk = 256;
    uint32_t full_chunks = total_pixels / pixels_per_chunk;
    uint32_t remaining = total_pixels % pixels_per_chunk;

    for (uint32_t i = 0; i < full_chunks; i++)
    {
        spi_write_blocking(SPI_PORT, buffer, 512);
    }
    if (remaining > 0)
    {
        spi_write_blocking(SPI_PORT, buffer, remaining * 2);
    }

    cs_deselect();

    spi1_unlock();
}

void ili9488_fill_rect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color)
{
    if (x >= ILI9488_WIDTH || y >= ILI9488_HEIGHT)
        return;
    if (x + w > ILI9488_WIDTH)
        w = ILI9488_WIDTH - x;
    if (y + h > ILI9488_HEIGHT)
        h = ILI9488_HEIGHT - y;

    spi1_lock();

    lcd_set_window(x, y, x + w, y + h);

    dc_data();
    cs_select();

    // RGB565: 2 bytes per pixel
    uint8_t high = color >> 8;
    uint8_t low = color & 0xFF;
    uint8_t buffer[512];

    for (int i = 0; i < 256; i++)
    {
        buffer[i * 2] = high;
        buffer[i * 2 + 1] = low;
    }

    uint32_t total_pixels = w * h;
    uint32_t pixels_written = 0;

    while (pixels_written < total_pixels)
    {
        uint32_t chunk = (total_pixels - pixels_written > 256) ? 256 : (total_pixels - pixels_written);
        spi_write_blocking(SPI_PORT, buffer, chunk * 2);
        pixels_written += chunk;
    }

    cs_deselect();

    spi1_unlock();
}

/*******************************************************************************
 * Font rendering (Font16: 11x16, Font24: 17x24)
 ******************************************************************************/

// Simplified Font16 data - ASCII 32-127, 11 pixels wide x 16 pixels high
// Each character uses 22 bytes (11 columns * 16 rows / 8 bits)
static const uint8_t font16_table[] = {
    // Space (32) - 22 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    // ! (33)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    // " (34)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00,
    // ... (simplified - just include essential chars)
    // For now, fill with zeros and implement key characters
};

// Minimal font data for digits 0-9 and letters A-Z, a-z
// 8x16 font for simplicity
static const uint8_t font8x16_data[96][16] = {
    // Space (32)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // ! (33)
    {0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
    // " (34)
    {0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // # (35)
    {0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00},
    // $ (36)
    {0x00, 0x18, 0x18, 0x7C, 0xC6, 0xC0, 0x78, 0x3C, 0x06, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00},
    // % (37)
    {0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00},
    // & (38)
    {0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
    // ' (39)
    {0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // ( (40)
    {0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00},
    // ) (41)
    {0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00},
    // * (42)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // + (43)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // , (44)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00},
    // - (45)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // . (46)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
    // / (47)
    {0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00},
    // 0 (48)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xCE, 0xD6, 0xD6, 0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // 1 (49)
    {0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00},
    // 2 (50)
    {0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00},
    // 3 (51)
    {0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // 4 (52)
    {0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00},
    // 5 (53)
    {0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // 6 (54)
    {0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // 7 (55)
    {0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00},
    // 8 (56)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // 9 (57)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00},
    // : (58)
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
    // ; (59)
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00},
    // < (60)
    {0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00},
    // = (61)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // > (62)
    {0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00},
    // ? (63)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
    // @ (64)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // A (65)
    {0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
    // B (66)
    {0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00},
    // C (67)
    {0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // D (68)
    {0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00},
    // E (69)
    {0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00},
    // F (70)
    {0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
    // G (71)
    {0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00},
    // H (72)
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
    // I (73)
    {0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // J (74)
    {0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00},
    // K (75)
    {0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
    // L (76)
    {0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00},
    // M (77)
    {0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
    // N (78)
    {0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
    // O (79)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // P (80)
    {0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
    // Q (81)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00},
    // R (82)
    {0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
    // S (83)
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // T (84)
    {0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // U (85)
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // V (86)
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00},
    // W (87)
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00},
    // X (88)
    {0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
    // Y (89)
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // Z (90)
    {0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00},
    // [ (91)
    {0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // \ (92)
    {0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00},
    // ] (93)
    {0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // ^ (94)
    {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // _ (95)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00},
    // ` (96)
    {0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // a (97)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
    // b (98)
    {0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // c (99)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // d (100)
    {0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
    // e (101)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // f (102)
    {0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
    // g (103)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00},
    // h (104)
    {0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
    // i (105)
    {0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // j (106)
    {0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00},
    // k (107)
    {0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
    // l (108)
    {0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
    // m (109)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00},
    // n (110)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},
    // o (111)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // p (112)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00},
    // q (113)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00},
    // r (114)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
    // s (115)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
    // t (116)
    {0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00},
    // u (117)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
    // v (118)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00},
    // w (119)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00},
    // x (120)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00},
    // y (121)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00},
    // z (122)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00},
    // { (123)
    {0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00},
    // | (124)
    {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
    // } (125)
    {0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00},
    // ~ (126)
    {0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // DEL (127) - blank
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

ili9488_font_t ili9488_font16 = {.table = (const uint8_t*)font8x16_data, .Width = 8, .Height = 16};

ili9488_font_t ili9488_font24 = {.table = (const uint8_t*)font8x16_data, // Use same data, scale up
                                 .Width = 12,
                                 .Height = 24};

void ili9488_draw_char(uint16_t x, uint16_t y, char c, ili9488_font_t* font, uint16_t fg_color, uint16_t bg_color)
{
    if (c < 32 || c > 127)
        c = ' ';

    uint16_t char_index = c - 32;
    const uint8_t* char_data = &font8x16_data[char_index][0];

    uint16_t font_w = 8;
    uint16_t font_h = 16;

    spi1_lock();

    lcd_set_window(x, y, x + font_w, y + font_h);

    dc_data();
    cs_select();

    for (uint16_t row = 0; row < font_h; row++)
    {
        uint8_t line = char_data[row];
        for (uint16_t col = 0; col < font_w; col++)
        {
            uint16_t color = (line & (0x80 >> col)) ? fg_color : bg_color;
            // RGB565: 2 bytes per pixel
            uint8_t buf[2] = {color >> 8, color & 0xFF};
            spi_write_blocking(SPI_PORT, buf, 2);
        }
    }

    cs_deselect();

    spi1_unlock();
}

void ili9488_draw_string(uint16_t x, uint16_t y, const char* str, ili9488_font_t* font, uint16_t fg_color,
                         uint16_t bg_color)
{
    uint16_t x_pos = x;

    while (*str)
    {
        if (x_pos + 8 > ILI9488_WIDTH)
        {
            x_pos = x;
            y += 16;
        }
        if (y + 16 > ILI9488_HEIGHT)
            break;

        ili9488_draw_char(x_pos, y, *str, font, fg_color, bg_color);
        x_pos += 8;
        str++;
    }
}

void ili9488_draw_number(uint16_t x, uint16_t y, int32_t number, ili9488_font_t* font, uint16_t fg_color,
                         uint16_t bg_color)
{
    char buf[16];
    snprintf(buf, sizeof(buf), "%ld", (long)number);
    ili9488_draw_string(x, y, buf, font, fg_color, bg_color);
}
